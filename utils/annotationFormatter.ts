
import type { ProcessedImageResult, CocoFormat, CocoInfo, CocoLicense, CocoImage, CocoAnnotation, CocoCategory, YoloExportData } from '../types';
import { YOLO_DATASET_YAML_TEMPLATE } from '../constants';

const getUniqueCategories = (results: ProcessedImageResult[]): CocoCategory[] => {
  const labels = new Set<string>();
  results.forEach(result => {
    result.boxes.forEach(box => labels.add(box.label));
  });
  return Array.from(labels).sort().map((label, index) => ({ // Ensure categories are sorted for consistent ID assignment
    id: index + 1, // COCO category IDs are 1-based
    name: label,
    supercategory: 'object', // Generic supercategory
  }));
};

export const convertToYOLO = (results: ProcessedImageResult[]): YoloExportData => {
  if (!results || results.length === 0) {
    const emptyYamlContent = YOLO_DATASET_YAML_TEMPLATE('images', 0, []);
    return {
      labelFile: { fileName: 'obj.names', content: '' },
      annotationFiles: [],
      yamlFile: { fileName: 'dataset.yaml', content: emptyYamlContent },
    };
  }

  const categoryMap = new Map<string, number>();
  let categoryIndex = 0;
  
  const allLabels = new Set<string>();
  results.forEach(result => {
    result.boxes.forEach(box => {
      allLabels.add(box.label);
    });
  });
  
  const sortedLabels = Array.from(allLabels).sort();
  sortedLabels.forEach(label => {
    categoryMap.set(label, categoryIndex++);
  });

  const objNamesContent = sortedLabels.join('\n');
  const labelFile = { fileName: 'obj.names', content: objNamesContent };

  const annotationFiles = results.map(result => {
    const yoloLines: string[] = [];
    result.boxes.forEach(box => {
      const classId = categoryMap.get(box.label);
      if (classId === undefined) {
        console.warn(`Label "${box.label}" not found in category map for YOLO export.`);
        return; 
      }

      const x_center = box.x_min + box.width / 2;
      const y_center = box.y_min + box.height / 2;
      yoloLines.push(`${classId} ${x_center.toFixed(6)} ${y_center.toFixed(6)} ${box.width.toFixed(6)} ${box.height.toFixed(6)}`);
    });

    const baseFileName = result.originalFileName.substring(0, result.originalFileName.lastIndexOf('.')) || result.originalFileName;
    return {
      fileName: `${baseFileName}.txt`,
      content: yoloLines.join('\n'),
    };
  });

  // Generate dataset.yaml content
  // Standard YOLO structure often has dataset.yaml in a 'data' folder, and images/labels folders at root or one level up.
  // We'll assume images/labels are in folders relative to where the zip is extracted.
  // The YAML paths should reflect this structure e.g. `../images`, `../labels` if yaml is in `data/`
  // For simplicity, we'll use `images` assuming yaml is at root with `images` and `labels` folders.
  const yamlContent = YOLO_DATASET_YAML_TEMPLATE(
    'images', // Path to images folder relative to where dataset.yaml will be (e.g. root of zip)
    sortedLabels.length,
    sortedLabels
  );
  const yamlFile = { fileName: 'dataset.yaml', content: yamlContent };

  return {
    labelFile,
    annotationFiles,
    yamlFile,
  };
};

export const convertToCOCO = (results: ProcessedImageResult[]): CocoFormat | null => {
  if (!results || results.length === 0) return null;

  const categories = getUniqueCategories(results);
  const categoryMap = new Map<string, number>(categories.map(cat => [cat.name, cat.id]));

  const cocoImages: CocoImage[] = [];
  const cocoAnnotations: CocoAnnotation[] = [];
  let annotationIdCounter = 1;

  results.forEach((result, imageIndex) => {
    const imageId = imageIndex + 1; 

    cocoImages.push({
      id: imageId,
      width: result.originalWidth,
      height: result.originalHeight,
      file_name: result.originalFileName, // COCO expects just the filename, not full path
      license: 1, 
      date_captured: new Date().toISOString(),
    });

    result.boxes.forEach(box => {
      const categoryId = categoryMap.get(box.label);
      if (categoryId === undefined) {
         console.warn(`Label "${box.label}" not found in category map for COCO export.`);
        return;
      }

      const pixelXMin = box.x_min * result.originalWidth;
      const pixelYMin = box.y_min * result.originalHeight;
      const pixelWidth = box.width * result.originalWidth;
      const pixelHeight = box.height * result.originalHeight;

      cocoAnnotations.push({
        id: annotationIdCounter++,
        image_id: imageId,
        category_id: categoryId,
        segmentation: [], 
        area: pixelWidth * pixelHeight,
        bbox: [pixelXMin, pixelYMin, pixelWidth, pixelHeight], 
        iscrowd: 0,
      });
    });
  });

  const cocoInfo: CocoInfo = {
    description: 'COCO format annotations generated by AI Image Annotator',
    version: '1.0',
    year: new Date().getFullYear(),
    contributor: 'Gemini AI',
    date_created: new Date().toISOString(),
  };

  const cocoLicenses: CocoLicense[] = [
    { id: 1, name: 'Default License', url: '' },
  ];

  return {
    info: cocoInfo,
    licenses: cocoLicenses,
    images: cocoImages,
    annotations: cocoAnnotations,
    categories: categories,
  };
};
